"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodRegistry = void 0;
const ethjs_1 = __importDefault(require("ethjs"));
const registry_map_json_1 = __importDefault(require("./registry-map.json"));
const abi_json_1 = __importDefault(require("./abi.json"));
class MethodRegistry {
    constructor(opts) {
        if (!opts.provider) {
            throw new Error("Missing required 'provider' option");
        }
        this.provider = opts.provider;
        this.eth = new ethjs_1.default(this.provider);
        const address = registry_map_json_1.default[opts.network || '1'];
        if (!address) {
            throw new Error('No method registry found on the requested network.');
        }
        this.registry = this.eth.contract(abi_json_1.default).at(address);
    }
    /**
   * @param bytes - The `0x`-prefixed hexadecimal string representing the four-byte signature of the contract method to lookup.
   */
    async lookup(bytes) {
        const result = await this.registry.entries(bytes);
        if (result) {
            return result[0];
        }
        return undefined;
    }
    parse(signature) {
        const rawName = signature.match(/^([^)(]*)\((.*)\)([^)(]*)$/u);
        let parsedName;
        if (rawName) {
            parsedName = rawName[1].charAt(0).toUpperCase() + rawName[1].slice(1).split(/(?=[A-Z])/u).join(' ');
        }
        else {
            parsedName = '';
        }
        if (rawName) {
            const match = signature.match(new RegExp(`${rawName[1]}\\(+([a-z1-9,()\\[\\]]+)\\)`, 'u'));
            let matches;
            let args = [];
            if (match) {
                matches = match[1].match(/[A-z1-9]+/gu);
                if (matches) {
                    args = matches.map((arg) => {
                        return { type: arg };
                    });
                }
            }
            return {
                name: parsedName,
                args,
            };
        }
        return {};
    }
}
exports.MethodRegistry = MethodRegistry;
//# sourceMappingURL=index.js.map